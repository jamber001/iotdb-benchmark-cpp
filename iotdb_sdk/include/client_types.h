/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef client_TYPES_H
#define client_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>
#include "common_types.h"




struct TSProtocolVersion {
  enum type {
    IOTDB_SERVICE_PROTOCOL_V1 = 0,
    IOTDB_SERVICE_PROTOCOL_V2 = 1,
    IOTDB_SERVICE_PROTOCOL_V3 = 2
  };
};

extern const std::map<int, const char*> _TSProtocolVersion_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSProtocolVersion::type& val);

std::string to_string(const TSProtocolVersion::type& val);

class TSQueryDataSet;

class TSQueryNonAlignDataSet;

class TSTracingInfo;

class TSExecuteStatementResp;

class TSOpenSessionResp;

class TSOpenSessionReq;

class TSCloseSessionReq;

class TSExecuteStatementReq;

class TSExecuteBatchStatementReq;

class TSGetOperationStatusReq;

class TSCancelOperationReq;

class TSCloseOperationReq;

class TSFetchResultsReq;

class TSFetchResultsResp;

class TSFetchMetadataResp;

class TSFetchMetadataReq;

class TSGetTimeZoneResp;

class TSSetTimeZoneReq;

class TSInsertRecordReq;

class TSInsertStringRecordReq;

class TSInsertTabletReq;

class TSInsertTabletsReq;

class TSInsertRecordsReq;

class TSInsertRecordsOfOneDeviceReq;

class TSInsertStringRecordsOfOneDeviceReq;

class TSInsertStringRecordsReq;

class TSDeleteDataReq;

class TSCreateTimeseriesReq;

class TSCreateAlignedTimeseriesReq;

class TSRawDataQueryReq;

class TSLastDataQueryReq;

class TSCreateMultiTimeseriesReq;

class ServerProperties;

class TSSetSchemaTemplateReq;

class TSCreateSchemaTemplateReq;

class TSAppendSchemaTemplateReq;

class TSPhysicalPlanReq;

class TSNodeStatusReq;

class TSNodeStatusResp;

class TSPruneSchemaTemplateReq;

class TSQueryTemplateReq;

class TSQueryTemplateResp;

class TSUnsetSchemaTemplateReq;

class TSDropSchemaTemplateReq;

class TSyncIdentityInfo;

class TSyncTransportMetaInfo;


class TSQueryDataSet : public virtual ::apache::thrift::TBase {
 public:

  TSQueryDataSet(const TSQueryDataSet&);
  TSQueryDataSet& operator=(const TSQueryDataSet&);
  TSQueryDataSet() : time() {
  }

  virtual ~TSQueryDataSet() noexcept;
  std::string time;
  std::vector<std::string>  valueList;
  std::vector<std::string>  bitmapList;

  void __set_time(const std::string& val);

  void __set_valueList(const std::vector<std::string> & val);

  void __set_bitmapList(const std::vector<std::string> & val);

  bool operator == (const TSQueryDataSet & rhs) const
  {
    if (!(time == rhs.time))
      return false;
    if (!(valueList == rhs.valueList))
      return false;
    if (!(bitmapList == rhs.bitmapList))
      return false;
    return true;
  }
  bool operator != (const TSQueryDataSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSQueryDataSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSQueryDataSet &a, TSQueryDataSet &b);

std::ostream& operator<<(std::ostream& out, const TSQueryDataSet& obj);


class TSQueryNonAlignDataSet : public virtual ::apache::thrift::TBase {
 public:

  TSQueryNonAlignDataSet(const TSQueryNonAlignDataSet&);
  TSQueryNonAlignDataSet& operator=(const TSQueryNonAlignDataSet&);
  TSQueryNonAlignDataSet() {
  }

  virtual ~TSQueryNonAlignDataSet() noexcept;
  std::vector<std::string>  timeList;
  std::vector<std::string>  valueList;

  void __set_timeList(const std::vector<std::string> & val);

  void __set_valueList(const std::vector<std::string> & val);

  bool operator == (const TSQueryNonAlignDataSet & rhs) const
  {
    if (!(timeList == rhs.timeList))
      return false;
    if (!(valueList == rhs.valueList))
      return false;
    return true;
  }
  bool operator != (const TSQueryNonAlignDataSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSQueryNonAlignDataSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSQueryNonAlignDataSet &a, TSQueryNonAlignDataSet &b);

std::ostream& operator<<(std::ostream& out, const TSQueryNonAlignDataSet& obj);

typedef struct _TSTracingInfo__isset {
  _TSTracingInfo__isset() : seriesPathNum(false), seqFileNum(false), unSeqFileNum(false), sequenceChunkNum(false), sequenceChunkPointNum(false), unsequenceChunkNum(false), unsequenceChunkPointNum(false), totalPageNum(false), overlappedPageNum(false) {}
  bool seriesPathNum :1;
  bool seqFileNum :1;
  bool unSeqFileNum :1;
  bool sequenceChunkNum :1;
  bool sequenceChunkPointNum :1;
  bool unsequenceChunkNum :1;
  bool unsequenceChunkPointNum :1;
  bool totalPageNum :1;
  bool overlappedPageNum :1;
} _TSTracingInfo__isset;

class TSTracingInfo : public virtual ::apache::thrift::TBase {
 public:

  TSTracingInfo(const TSTracingInfo&);
  TSTracingInfo& operator=(const TSTracingInfo&);
  TSTracingInfo() : seriesPathNum(0), seqFileNum(0), unSeqFileNum(0), sequenceChunkNum(0), sequenceChunkPointNum(0), unsequenceChunkNum(0), unsequenceChunkPointNum(0), totalPageNum(0), overlappedPageNum(0) {
  }

  virtual ~TSTracingInfo() noexcept;
  std::vector<std::string>  activityList;
  std::vector<int64_t>  elapsedTimeList;
  int32_t seriesPathNum;
  int32_t seqFileNum;
  int32_t unSeqFileNum;
  int32_t sequenceChunkNum;
  int64_t sequenceChunkPointNum;
  int32_t unsequenceChunkNum;
  int64_t unsequenceChunkPointNum;
  int32_t totalPageNum;
  int32_t overlappedPageNum;

  _TSTracingInfo__isset __isset;

  void __set_activityList(const std::vector<std::string> & val);

  void __set_elapsedTimeList(const std::vector<int64_t> & val);

  void __set_seriesPathNum(const int32_t val);

  void __set_seqFileNum(const int32_t val);

  void __set_unSeqFileNum(const int32_t val);

  void __set_sequenceChunkNum(const int32_t val);

  void __set_sequenceChunkPointNum(const int64_t val);

  void __set_unsequenceChunkNum(const int32_t val);

  void __set_unsequenceChunkPointNum(const int64_t val);

  void __set_totalPageNum(const int32_t val);

  void __set_overlappedPageNum(const int32_t val);

  bool operator == (const TSTracingInfo & rhs) const
  {
    if (!(activityList == rhs.activityList))
      return false;
    if (!(elapsedTimeList == rhs.elapsedTimeList))
      return false;
    if (__isset.seriesPathNum != rhs.__isset.seriesPathNum)
      return false;
    else if (__isset.seriesPathNum && !(seriesPathNum == rhs.seriesPathNum))
      return false;
    if (__isset.seqFileNum != rhs.__isset.seqFileNum)
      return false;
    else if (__isset.seqFileNum && !(seqFileNum == rhs.seqFileNum))
      return false;
    if (__isset.unSeqFileNum != rhs.__isset.unSeqFileNum)
      return false;
    else if (__isset.unSeqFileNum && !(unSeqFileNum == rhs.unSeqFileNum))
      return false;
    if (__isset.sequenceChunkNum != rhs.__isset.sequenceChunkNum)
      return false;
    else if (__isset.sequenceChunkNum && !(sequenceChunkNum == rhs.sequenceChunkNum))
      return false;
    if (__isset.sequenceChunkPointNum != rhs.__isset.sequenceChunkPointNum)
      return false;
    else if (__isset.sequenceChunkPointNum && !(sequenceChunkPointNum == rhs.sequenceChunkPointNum))
      return false;
    if (__isset.unsequenceChunkNum != rhs.__isset.unsequenceChunkNum)
      return false;
    else if (__isset.unsequenceChunkNum && !(unsequenceChunkNum == rhs.unsequenceChunkNum))
      return false;
    if (__isset.unsequenceChunkPointNum != rhs.__isset.unsequenceChunkPointNum)
      return false;
    else if (__isset.unsequenceChunkPointNum && !(unsequenceChunkPointNum == rhs.unsequenceChunkPointNum))
      return false;
    if (__isset.totalPageNum != rhs.__isset.totalPageNum)
      return false;
    else if (__isset.totalPageNum && !(totalPageNum == rhs.totalPageNum))
      return false;
    if (__isset.overlappedPageNum != rhs.__isset.overlappedPageNum)
      return false;
    else if (__isset.overlappedPageNum && !(overlappedPageNum == rhs.overlappedPageNum))
      return false;
    return true;
  }
  bool operator != (const TSTracingInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSTracingInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSTracingInfo &a, TSTracingInfo &b);

std::ostream& operator<<(std::ostream& out, const TSTracingInfo& obj);

typedef struct _TSExecuteStatementResp__isset {
  _TSExecuteStatementResp__isset() : queryId(false), columns(false), operationType(false), ignoreTimeStamp(false), dataTypeList(false), queryDataSet(false), nonAlignQueryDataSet(false), columnNameIndexMap(false), sgColumns(false), aliasColumns(false), tracingInfo(false) {}
  bool queryId :1;
  bool columns :1;
  bool operationType :1;
  bool ignoreTimeStamp :1;
  bool dataTypeList :1;
  bool queryDataSet :1;
  bool nonAlignQueryDataSet :1;
  bool columnNameIndexMap :1;
  bool sgColumns :1;
  bool aliasColumns :1;
  bool tracingInfo :1;
} _TSExecuteStatementResp__isset;

class TSExecuteStatementResp : public virtual ::apache::thrift::TBase {
 public:

  TSExecuteStatementResp(const TSExecuteStatementResp&);
  TSExecuteStatementResp& operator=(const TSExecuteStatementResp&);
  TSExecuteStatementResp() : queryId(0), operationType(), ignoreTimeStamp(0) {
  }

  virtual ~TSExecuteStatementResp() noexcept;
   ::TSStatus status;
  int64_t queryId;
  std::vector<std::string>  columns;
  std::string operationType;
  bool ignoreTimeStamp;
  std::vector<std::string>  dataTypeList;
  TSQueryDataSet queryDataSet;
  TSQueryNonAlignDataSet nonAlignQueryDataSet;
  std::map<std::string, int32_t>  columnNameIndexMap;
  std::vector<std::string>  sgColumns;
  std::vector<int8_t>  aliasColumns;
  TSTracingInfo tracingInfo;

  _TSExecuteStatementResp__isset __isset;

  void __set_status(const  ::TSStatus& val);

  void __set_queryId(const int64_t val);

  void __set_columns(const std::vector<std::string> & val);

  void __set_operationType(const std::string& val);

  void __set_ignoreTimeStamp(const bool val);

  void __set_dataTypeList(const std::vector<std::string> & val);

  void __set_queryDataSet(const TSQueryDataSet& val);

  void __set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val);

  void __set_columnNameIndexMap(const std::map<std::string, int32_t> & val);

  void __set_sgColumns(const std::vector<std::string> & val);

  void __set_aliasColumns(const std::vector<int8_t> & val);

  void __set_tracingInfo(const TSTracingInfo& val);

  bool operator == (const TSExecuteStatementResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.queryId != rhs.__isset.queryId)
      return false;
    else if (__isset.queryId && !(queryId == rhs.queryId))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.operationType != rhs.__isset.operationType)
      return false;
    else if (__isset.operationType && !(operationType == rhs.operationType))
      return false;
    if (__isset.ignoreTimeStamp != rhs.__isset.ignoreTimeStamp)
      return false;
    else if (__isset.ignoreTimeStamp && !(ignoreTimeStamp == rhs.ignoreTimeStamp))
      return false;
    if (__isset.dataTypeList != rhs.__isset.dataTypeList)
      return false;
    else if (__isset.dataTypeList && !(dataTypeList == rhs.dataTypeList))
      return false;
    if (__isset.queryDataSet != rhs.__isset.queryDataSet)
      return false;
    else if (__isset.queryDataSet && !(queryDataSet == rhs.queryDataSet))
      return false;
    if (__isset.nonAlignQueryDataSet != rhs.__isset.nonAlignQueryDataSet)
      return false;
    else if (__isset.nonAlignQueryDataSet && !(nonAlignQueryDataSet == rhs.nonAlignQueryDataSet))
      return false;
    if (__isset.columnNameIndexMap != rhs.__isset.columnNameIndexMap)
      return false;
    else if (__isset.columnNameIndexMap && !(columnNameIndexMap == rhs.columnNameIndexMap))
      return false;
    if (__isset.sgColumns != rhs.__isset.sgColumns)
      return false;
    else if (__isset.sgColumns && !(sgColumns == rhs.sgColumns))
      return false;
    if (__isset.aliasColumns != rhs.__isset.aliasColumns)
      return false;
    else if (__isset.aliasColumns && !(aliasColumns == rhs.aliasColumns))
      return false;
    if (__isset.tracingInfo != rhs.__isset.tracingInfo)
      return false;
    else if (__isset.tracingInfo && !(tracingInfo == rhs.tracingInfo))
      return false;
    return true;
  }
  bool operator != (const TSExecuteStatementResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSExecuteStatementResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSExecuteStatementResp &a, TSExecuteStatementResp &b);

std::ostream& operator<<(std::ostream& out, const TSExecuteStatementResp& obj);

typedef struct _TSOpenSessionResp__isset {
  _TSOpenSessionResp__isset() : sessionId(false), configuration(false) {}
  bool sessionId :1;
  bool configuration :1;
} _TSOpenSessionResp__isset;

class TSOpenSessionResp : public virtual ::apache::thrift::TBase {
 public:

  TSOpenSessionResp(const TSOpenSessionResp&);
  TSOpenSessionResp& operator=(const TSOpenSessionResp&);
  TSOpenSessionResp() : serverProtocolVersion((TSProtocolVersion::type)0), sessionId(0) {
    serverProtocolVersion = (TSProtocolVersion::type)0;

  }

  virtual ~TSOpenSessionResp() noexcept;
   ::TSStatus status;
  /**
   * 
   * @see TSProtocolVersion
   */
  TSProtocolVersion::type serverProtocolVersion;
  int64_t sessionId;
  std::map<std::string, std::string>  configuration;

  _TSOpenSessionResp__isset __isset;

  void __set_status(const  ::TSStatus& val);

  void __set_serverProtocolVersion(const TSProtocolVersion::type val);

  void __set_sessionId(const int64_t val);

  void __set_configuration(const std::map<std::string, std::string> & val);

  bool operator == (const TSOpenSessionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(serverProtocolVersion == rhs.serverProtocolVersion))
      return false;
    if (__isset.sessionId != rhs.__isset.sessionId)
      return false;
    else if (__isset.sessionId && !(sessionId == rhs.sessionId))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TSOpenSessionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSOpenSessionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSOpenSessionResp &a, TSOpenSessionResp &b);

std::ostream& operator<<(std::ostream& out, const TSOpenSessionResp& obj);

typedef struct _TSOpenSessionReq__isset {
  _TSOpenSessionReq__isset() : username(false), password(false), configuration(false) {}
  bool username :1;
  bool password :1;
  bool configuration :1;
} _TSOpenSessionReq__isset;

class TSOpenSessionReq : public virtual ::apache::thrift::TBase {
 public:

  TSOpenSessionReq(const TSOpenSessionReq&);
  TSOpenSessionReq& operator=(const TSOpenSessionReq&);
  TSOpenSessionReq() : client_protocol((TSProtocolVersion::type)2), zoneId(), username(), password() {
    client_protocol = (TSProtocolVersion::type)2;

  }

  virtual ~TSOpenSessionReq() noexcept;
  /**
   * 
   * @see TSProtocolVersion
   */
  TSProtocolVersion::type client_protocol;
  std::string zoneId;
  std::string username;
  std::string password;
  std::map<std::string, std::string>  configuration;

  _TSOpenSessionReq__isset __isset;

  void __set_client_protocol(const TSProtocolVersion::type val);

  void __set_zoneId(const std::string& val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_configuration(const std::map<std::string, std::string> & val);

  bool operator == (const TSOpenSessionReq & rhs) const
  {
    if (!(client_protocol == rhs.client_protocol))
      return false;
    if (!(zoneId == rhs.zoneId))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TSOpenSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSOpenSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSOpenSessionReq &a, TSOpenSessionReq &b);

std::ostream& operator<<(std::ostream& out, const TSOpenSessionReq& obj);


class TSCloseSessionReq : public virtual ::apache::thrift::TBase {
 public:

  TSCloseSessionReq(const TSCloseSessionReq&);
  TSCloseSessionReq& operator=(const TSCloseSessionReq&);
  TSCloseSessionReq() : sessionId(0) {
  }

  virtual ~TSCloseSessionReq() noexcept;
  int64_t sessionId;

  void __set_sessionId(const int64_t val);

  bool operator == (const TSCloseSessionReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    return true;
  }
  bool operator != (const TSCloseSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSCloseSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSCloseSessionReq &a, TSCloseSessionReq &b);

std::ostream& operator<<(std::ostream& out, const TSCloseSessionReq& obj);

typedef struct _TSExecuteStatementReq__isset {
  _TSExecuteStatementReq__isset() : fetchSize(false), timeout(false), enableRedirectQuery(false), jdbcQuery(false) {}
  bool fetchSize :1;
  bool timeout :1;
  bool enableRedirectQuery :1;
  bool jdbcQuery :1;
} _TSExecuteStatementReq__isset;

class TSExecuteStatementReq : public virtual ::apache::thrift::TBase {
 public:

  TSExecuteStatementReq(const TSExecuteStatementReq&);
  TSExecuteStatementReq& operator=(const TSExecuteStatementReq&);
  TSExecuteStatementReq() : sessionId(0), statement(), statementId(0), fetchSize(0), timeout(0), enableRedirectQuery(0), jdbcQuery(0) {
  }

  virtual ~TSExecuteStatementReq() noexcept;
  int64_t sessionId;
  std::string statement;
  int64_t statementId;
  int32_t fetchSize;
  int64_t timeout;
  bool enableRedirectQuery;
  bool jdbcQuery;

  _TSExecuteStatementReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_statement(const std::string& val);

  void __set_statementId(const int64_t val);

  void __set_fetchSize(const int32_t val);

  void __set_timeout(const int64_t val);

  void __set_enableRedirectQuery(const bool val);

  void __set_jdbcQuery(const bool val);

  bool operator == (const TSExecuteStatementReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(statement == rhs.statement))
      return false;
    if (!(statementId == rhs.statementId))
      return false;
    if (__isset.fetchSize != rhs.__isset.fetchSize)
      return false;
    else if (__isset.fetchSize && !(fetchSize == rhs.fetchSize))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    if (__isset.enableRedirectQuery != rhs.__isset.enableRedirectQuery)
      return false;
    else if (__isset.enableRedirectQuery && !(enableRedirectQuery == rhs.enableRedirectQuery))
      return false;
    if (__isset.jdbcQuery != rhs.__isset.jdbcQuery)
      return false;
    else if (__isset.jdbcQuery && !(jdbcQuery == rhs.jdbcQuery))
      return false;
    return true;
  }
  bool operator != (const TSExecuteStatementReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSExecuteStatementReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSExecuteStatementReq &a, TSExecuteStatementReq &b);

std::ostream& operator<<(std::ostream& out, const TSExecuteStatementReq& obj);


class TSExecuteBatchStatementReq : public virtual ::apache::thrift::TBase {
 public:

  TSExecuteBatchStatementReq(const TSExecuteBatchStatementReq&);
  TSExecuteBatchStatementReq& operator=(const TSExecuteBatchStatementReq&);
  TSExecuteBatchStatementReq() : sessionId(0) {
  }

  virtual ~TSExecuteBatchStatementReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  statements;

  void __set_sessionId(const int64_t val);

  void __set_statements(const std::vector<std::string> & val);

  bool operator == (const TSExecuteBatchStatementReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(statements == rhs.statements))
      return false;
    return true;
  }
  bool operator != (const TSExecuteBatchStatementReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSExecuteBatchStatementReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSExecuteBatchStatementReq &a, TSExecuteBatchStatementReq &b);

std::ostream& operator<<(std::ostream& out, const TSExecuteBatchStatementReq& obj);


class TSGetOperationStatusReq : public virtual ::apache::thrift::TBase {
 public:

  TSGetOperationStatusReq(const TSGetOperationStatusReq&);
  TSGetOperationStatusReq& operator=(const TSGetOperationStatusReq&);
  TSGetOperationStatusReq() : sessionId(0), queryId(0) {
  }

  virtual ~TSGetOperationStatusReq() noexcept;
  int64_t sessionId;
  int64_t queryId;

  void __set_sessionId(const int64_t val);

  void __set_queryId(const int64_t val);

  bool operator == (const TSGetOperationStatusReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(queryId == rhs.queryId))
      return false;
    return true;
  }
  bool operator != (const TSGetOperationStatusReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSGetOperationStatusReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSGetOperationStatusReq &a, TSGetOperationStatusReq &b);

std::ostream& operator<<(std::ostream& out, const TSGetOperationStatusReq& obj);


class TSCancelOperationReq : public virtual ::apache::thrift::TBase {
 public:

  TSCancelOperationReq(const TSCancelOperationReq&);
  TSCancelOperationReq& operator=(const TSCancelOperationReq&);
  TSCancelOperationReq() : sessionId(0), queryId(0) {
  }

  virtual ~TSCancelOperationReq() noexcept;
  int64_t sessionId;
  int64_t queryId;

  void __set_sessionId(const int64_t val);

  void __set_queryId(const int64_t val);

  bool operator == (const TSCancelOperationReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(queryId == rhs.queryId))
      return false;
    return true;
  }
  bool operator != (const TSCancelOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSCancelOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSCancelOperationReq &a, TSCancelOperationReq &b);

std::ostream& operator<<(std::ostream& out, const TSCancelOperationReq& obj);

typedef struct _TSCloseOperationReq__isset {
  _TSCloseOperationReq__isset() : queryId(false), statementId(false) {}
  bool queryId :1;
  bool statementId :1;
} _TSCloseOperationReq__isset;

class TSCloseOperationReq : public virtual ::apache::thrift::TBase {
 public:

  TSCloseOperationReq(const TSCloseOperationReq&);
  TSCloseOperationReq& operator=(const TSCloseOperationReq&);
  TSCloseOperationReq() : sessionId(0), queryId(0), statementId(0) {
  }

  virtual ~TSCloseOperationReq() noexcept;
  int64_t sessionId;
  int64_t queryId;
  int64_t statementId;

  _TSCloseOperationReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_queryId(const int64_t val);

  void __set_statementId(const int64_t val);

  bool operator == (const TSCloseOperationReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (__isset.queryId != rhs.__isset.queryId)
      return false;
    else if (__isset.queryId && !(queryId == rhs.queryId))
      return false;
    if (__isset.statementId != rhs.__isset.statementId)
      return false;
    else if (__isset.statementId && !(statementId == rhs.statementId))
      return false;
    return true;
  }
  bool operator != (const TSCloseOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSCloseOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSCloseOperationReq &a, TSCloseOperationReq &b);

std::ostream& operator<<(std::ostream& out, const TSCloseOperationReq& obj);

typedef struct _TSFetchResultsReq__isset {
  _TSFetchResultsReq__isset() : timeout(false) {}
  bool timeout :1;
} _TSFetchResultsReq__isset;

class TSFetchResultsReq : public virtual ::apache::thrift::TBase {
 public:

  TSFetchResultsReq(const TSFetchResultsReq&);
  TSFetchResultsReq& operator=(const TSFetchResultsReq&);
  TSFetchResultsReq() : sessionId(0), statement(), fetchSize(0), queryId(0), isAlign(0), timeout(0) {
  }

  virtual ~TSFetchResultsReq() noexcept;
  int64_t sessionId;
  std::string statement;
  int32_t fetchSize;
  int64_t queryId;
  bool isAlign;
  int64_t timeout;

  _TSFetchResultsReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_statement(const std::string& val);

  void __set_fetchSize(const int32_t val);

  void __set_queryId(const int64_t val);

  void __set_isAlign(const bool val);

  void __set_timeout(const int64_t val);

  bool operator == (const TSFetchResultsReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(statement == rhs.statement))
      return false;
    if (!(fetchSize == rhs.fetchSize))
      return false;
    if (!(queryId == rhs.queryId))
      return false;
    if (!(isAlign == rhs.isAlign))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const TSFetchResultsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSFetchResultsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSFetchResultsReq &a, TSFetchResultsReq &b);

std::ostream& operator<<(std::ostream& out, const TSFetchResultsReq& obj);

typedef struct _TSFetchResultsResp__isset {
  _TSFetchResultsResp__isset() : queryDataSet(false), nonAlignQueryDataSet(false) {}
  bool queryDataSet :1;
  bool nonAlignQueryDataSet :1;
} _TSFetchResultsResp__isset;

class TSFetchResultsResp : public virtual ::apache::thrift::TBase {
 public:

  TSFetchResultsResp(const TSFetchResultsResp&);
  TSFetchResultsResp& operator=(const TSFetchResultsResp&);
  TSFetchResultsResp() : hasResultSet(0), isAlign(0) {
  }

  virtual ~TSFetchResultsResp() noexcept;
   ::TSStatus status;
  bool hasResultSet;
  bool isAlign;
  TSQueryDataSet queryDataSet;
  TSQueryNonAlignDataSet nonAlignQueryDataSet;

  _TSFetchResultsResp__isset __isset;

  void __set_status(const  ::TSStatus& val);

  void __set_hasResultSet(const bool val);

  void __set_isAlign(const bool val);

  void __set_queryDataSet(const TSQueryDataSet& val);

  void __set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val);

  bool operator == (const TSFetchResultsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(hasResultSet == rhs.hasResultSet))
      return false;
    if (!(isAlign == rhs.isAlign))
      return false;
    if (__isset.queryDataSet != rhs.__isset.queryDataSet)
      return false;
    else if (__isset.queryDataSet && !(queryDataSet == rhs.queryDataSet))
      return false;
    if (__isset.nonAlignQueryDataSet != rhs.__isset.nonAlignQueryDataSet)
      return false;
    else if (__isset.nonAlignQueryDataSet && !(nonAlignQueryDataSet == rhs.nonAlignQueryDataSet))
      return false;
    return true;
  }
  bool operator != (const TSFetchResultsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSFetchResultsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSFetchResultsResp &a, TSFetchResultsResp &b);

std::ostream& operator<<(std::ostream& out, const TSFetchResultsResp& obj);

typedef struct _TSFetchMetadataResp__isset {
  _TSFetchMetadataResp__isset() : metadataInJson(false), columnsList(false), dataType(false) {}
  bool metadataInJson :1;
  bool columnsList :1;
  bool dataType :1;
} _TSFetchMetadataResp__isset;

class TSFetchMetadataResp : public virtual ::apache::thrift::TBase {
 public:

  TSFetchMetadataResp(const TSFetchMetadataResp&);
  TSFetchMetadataResp& operator=(const TSFetchMetadataResp&);
  TSFetchMetadataResp() : metadataInJson(), dataType() {
  }

  virtual ~TSFetchMetadataResp() noexcept;
   ::TSStatus status;
  std::string metadataInJson;
  std::vector<std::string>  columnsList;
  std::string dataType;

  _TSFetchMetadataResp__isset __isset;

  void __set_status(const  ::TSStatus& val);

  void __set_metadataInJson(const std::string& val);

  void __set_columnsList(const std::vector<std::string> & val);

  void __set_dataType(const std::string& val);

  bool operator == (const TSFetchMetadataResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.metadataInJson != rhs.__isset.metadataInJson)
      return false;
    else if (__isset.metadataInJson && !(metadataInJson == rhs.metadataInJson))
      return false;
    if (__isset.columnsList != rhs.__isset.columnsList)
      return false;
    else if (__isset.columnsList && !(columnsList == rhs.columnsList))
      return false;
    if (__isset.dataType != rhs.__isset.dataType)
      return false;
    else if (__isset.dataType && !(dataType == rhs.dataType))
      return false;
    return true;
  }
  bool operator != (const TSFetchMetadataResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSFetchMetadataResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSFetchMetadataResp &a, TSFetchMetadataResp &b);

std::ostream& operator<<(std::ostream& out, const TSFetchMetadataResp& obj);

typedef struct _TSFetchMetadataReq__isset {
  _TSFetchMetadataReq__isset() : columnPath(false) {}
  bool columnPath :1;
} _TSFetchMetadataReq__isset;

class TSFetchMetadataReq : public virtual ::apache::thrift::TBase {
 public:

  TSFetchMetadataReq(const TSFetchMetadataReq&);
  TSFetchMetadataReq& operator=(const TSFetchMetadataReq&);
  TSFetchMetadataReq() : sessionId(0), type(), columnPath() {
  }

  virtual ~TSFetchMetadataReq() noexcept;
  int64_t sessionId;
  std::string type;
  std::string columnPath;

  _TSFetchMetadataReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_type(const std::string& val);

  void __set_columnPath(const std::string& val);

  bool operator == (const TSFetchMetadataReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.columnPath != rhs.__isset.columnPath)
      return false;
    else if (__isset.columnPath && !(columnPath == rhs.columnPath))
      return false;
    return true;
  }
  bool operator != (const TSFetchMetadataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSFetchMetadataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSFetchMetadataReq &a, TSFetchMetadataReq &b);

std::ostream& operator<<(std::ostream& out, const TSFetchMetadataReq& obj);


class TSGetTimeZoneResp : public virtual ::apache::thrift::TBase {
 public:

  TSGetTimeZoneResp(const TSGetTimeZoneResp&);
  TSGetTimeZoneResp& operator=(const TSGetTimeZoneResp&);
  TSGetTimeZoneResp() : timeZone() {
  }

  virtual ~TSGetTimeZoneResp() noexcept;
   ::TSStatus status;
  std::string timeZone;

  void __set_status(const  ::TSStatus& val);

  void __set_timeZone(const std::string& val);

  bool operator == (const TSGetTimeZoneResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(timeZone == rhs.timeZone))
      return false;
    return true;
  }
  bool operator != (const TSGetTimeZoneResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSGetTimeZoneResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSGetTimeZoneResp &a, TSGetTimeZoneResp &b);

std::ostream& operator<<(std::ostream& out, const TSGetTimeZoneResp& obj);


class TSSetTimeZoneReq : public virtual ::apache::thrift::TBase {
 public:

  TSSetTimeZoneReq(const TSSetTimeZoneReq&);
  TSSetTimeZoneReq& operator=(const TSSetTimeZoneReq&);
  TSSetTimeZoneReq() : sessionId(0), timeZone() {
  }

  virtual ~TSSetTimeZoneReq() noexcept;
  int64_t sessionId;
  std::string timeZone;

  void __set_sessionId(const int64_t val);

  void __set_timeZone(const std::string& val);

  bool operator == (const TSSetTimeZoneReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(timeZone == rhs.timeZone))
      return false;
    return true;
  }
  bool operator != (const TSSetTimeZoneReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSSetTimeZoneReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSSetTimeZoneReq &a, TSSetTimeZoneReq &b);

std::ostream& operator<<(std::ostream& out, const TSSetTimeZoneReq& obj);

typedef struct _TSInsertRecordReq__isset {
  _TSInsertRecordReq__isset() : isAligned(false) {}
  bool isAligned :1;
} _TSInsertRecordReq__isset;

class TSInsertRecordReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertRecordReq(const TSInsertRecordReq&);
  TSInsertRecordReq& operator=(const TSInsertRecordReq&);
  TSInsertRecordReq() : sessionId(0), prefixPath(), values(), timestamp(0), isAligned(0) {
  }

  virtual ~TSInsertRecordReq() noexcept;
  int64_t sessionId;
  std::string prefixPath;
  std::vector<std::string>  measurements;
  std::string values;
  int64_t timestamp;
  bool isAligned;

  _TSInsertRecordReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPath(const std::string& val);

  void __set_measurements(const std::vector<std::string> & val);

  void __set_values(const std::string& val);

  void __set_timestamp(const int64_t val);

  void __set_isAligned(const bool val);

  bool operator == (const TSInsertRecordReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    if (!(measurements == rhs.measurements))
      return false;
    if (!(values == rhs.values))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    return true;
  }
  bool operator != (const TSInsertRecordReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertRecordReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertRecordReq &a, TSInsertRecordReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertRecordReq& obj);

typedef struct _TSInsertStringRecordReq__isset {
  _TSInsertStringRecordReq__isset() : isAligned(false), timeout(false) {}
  bool isAligned :1;
  bool timeout :1;
} _TSInsertStringRecordReq__isset;

class TSInsertStringRecordReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertStringRecordReq(const TSInsertStringRecordReq&);
  TSInsertStringRecordReq& operator=(const TSInsertStringRecordReq&);
  TSInsertStringRecordReq() : sessionId(0), prefixPath(), timestamp(0), isAligned(0), timeout(0) {
  }

  virtual ~TSInsertStringRecordReq() noexcept;
  int64_t sessionId;
  std::string prefixPath;
  std::vector<std::string>  measurements;
  std::vector<std::string>  values;
  int64_t timestamp;
  bool isAligned;
  int64_t timeout;

  _TSInsertStringRecordReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPath(const std::string& val);

  void __set_measurements(const std::vector<std::string> & val);

  void __set_values(const std::vector<std::string> & val);

  void __set_timestamp(const int64_t val);

  void __set_isAligned(const bool val);

  void __set_timeout(const int64_t val);

  bool operator == (const TSInsertStringRecordReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    if (!(measurements == rhs.measurements))
      return false;
    if (!(values == rhs.values))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const TSInsertStringRecordReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertStringRecordReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertStringRecordReq &a, TSInsertStringRecordReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordReq& obj);

typedef struct _TSInsertTabletReq__isset {
  _TSInsertTabletReq__isset() : isAligned(false) {}
  bool isAligned :1;
} _TSInsertTabletReq__isset;

class TSInsertTabletReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertTabletReq(const TSInsertTabletReq&);
  TSInsertTabletReq& operator=(const TSInsertTabletReq&);
  TSInsertTabletReq() : sessionId(0), prefixPath(), values(), timestamps(), size(0), isAligned(0) {
  }

  virtual ~TSInsertTabletReq() noexcept;
  int64_t sessionId;
  std::string prefixPath;
  std::vector<std::string>  measurements;
  std::string values;
  std::string timestamps;
  std::vector<int32_t>  types;
  int32_t size;
  bool isAligned;

  _TSInsertTabletReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPath(const std::string& val);

  void __set_measurements(const std::vector<std::string> & val);

  void __set_values(const std::string& val);

  void __set_timestamps(const std::string& val);

  void __set_types(const std::vector<int32_t> & val);

  void __set_size(const int32_t val);

  void __set_isAligned(const bool val);

  bool operator == (const TSInsertTabletReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    if (!(measurements == rhs.measurements))
      return false;
    if (!(values == rhs.values))
      return false;
    if (!(timestamps == rhs.timestamps))
      return false;
    if (!(types == rhs.types))
      return false;
    if (!(size == rhs.size))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    return true;
  }
  bool operator != (const TSInsertTabletReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertTabletReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertTabletReq &a, TSInsertTabletReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertTabletReq& obj);

typedef struct _TSInsertTabletsReq__isset {
  _TSInsertTabletsReq__isset() : isAligned(false) {}
  bool isAligned :1;
} _TSInsertTabletsReq__isset;

class TSInsertTabletsReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertTabletsReq(const TSInsertTabletsReq&);
  TSInsertTabletsReq& operator=(const TSInsertTabletsReq&);
  TSInsertTabletsReq() : sessionId(0), isAligned(0) {
  }

  virtual ~TSInsertTabletsReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  prefixPaths;
  std::vector<std::vector<std::string> >  measurementsList;
  std::vector<std::string>  valuesList;
  std::vector<std::string>  timestampsList;
  std::vector<std::vector<int32_t> >  typesList;
  std::vector<int32_t>  sizeList;
  bool isAligned;

  _TSInsertTabletsReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPaths(const std::vector<std::string> & val);

  void __set_measurementsList(const std::vector<std::vector<std::string> > & val);

  void __set_valuesList(const std::vector<std::string> & val);

  void __set_timestampsList(const std::vector<std::string> & val);

  void __set_typesList(const std::vector<std::vector<int32_t> > & val);

  void __set_sizeList(const std::vector<int32_t> & val);

  void __set_isAligned(const bool val);

  bool operator == (const TSInsertTabletsReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPaths == rhs.prefixPaths))
      return false;
    if (!(measurementsList == rhs.measurementsList))
      return false;
    if (!(valuesList == rhs.valuesList))
      return false;
    if (!(timestampsList == rhs.timestampsList))
      return false;
    if (!(typesList == rhs.typesList))
      return false;
    if (!(sizeList == rhs.sizeList))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    return true;
  }
  bool operator != (const TSInsertTabletsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertTabletsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertTabletsReq &a, TSInsertTabletsReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertTabletsReq& obj);

typedef struct _TSInsertRecordsReq__isset {
  _TSInsertRecordsReq__isset() : isAligned(false) {}
  bool isAligned :1;
} _TSInsertRecordsReq__isset;

class TSInsertRecordsReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertRecordsReq(const TSInsertRecordsReq&);
  TSInsertRecordsReq& operator=(const TSInsertRecordsReq&);
  TSInsertRecordsReq() : sessionId(0), isAligned(0) {
  }

  virtual ~TSInsertRecordsReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  prefixPaths;
  std::vector<std::vector<std::string> >  measurementsList;
  std::vector<std::string>  valuesList;
  std::vector<int64_t>  timestamps;
  bool isAligned;

  _TSInsertRecordsReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPaths(const std::vector<std::string> & val);

  void __set_measurementsList(const std::vector<std::vector<std::string> > & val);

  void __set_valuesList(const std::vector<std::string> & val);

  void __set_timestamps(const std::vector<int64_t> & val);

  void __set_isAligned(const bool val);

  bool operator == (const TSInsertRecordsReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPaths == rhs.prefixPaths))
      return false;
    if (!(measurementsList == rhs.measurementsList))
      return false;
    if (!(valuesList == rhs.valuesList))
      return false;
    if (!(timestamps == rhs.timestamps))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    return true;
  }
  bool operator != (const TSInsertRecordsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertRecordsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertRecordsReq &a, TSInsertRecordsReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertRecordsReq& obj);

typedef struct _TSInsertRecordsOfOneDeviceReq__isset {
  _TSInsertRecordsOfOneDeviceReq__isset() : isAligned(false) {}
  bool isAligned :1;
} _TSInsertRecordsOfOneDeviceReq__isset;

class TSInsertRecordsOfOneDeviceReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertRecordsOfOneDeviceReq(const TSInsertRecordsOfOneDeviceReq&);
  TSInsertRecordsOfOneDeviceReq& operator=(const TSInsertRecordsOfOneDeviceReq&);
  TSInsertRecordsOfOneDeviceReq() : sessionId(0), prefixPath(), isAligned(0) {
  }

  virtual ~TSInsertRecordsOfOneDeviceReq() noexcept;
  int64_t sessionId;
  std::string prefixPath;
  std::vector<std::vector<std::string> >  measurementsList;
  std::vector<std::string>  valuesList;
  std::vector<int64_t>  timestamps;
  bool isAligned;

  _TSInsertRecordsOfOneDeviceReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPath(const std::string& val);

  void __set_measurementsList(const std::vector<std::vector<std::string> > & val);

  void __set_valuesList(const std::vector<std::string> & val);

  void __set_timestamps(const std::vector<int64_t> & val);

  void __set_isAligned(const bool val);

  bool operator == (const TSInsertRecordsOfOneDeviceReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    if (!(measurementsList == rhs.measurementsList))
      return false;
    if (!(valuesList == rhs.valuesList))
      return false;
    if (!(timestamps == rhs.timestamps))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    return true;
  }
  bool operator != (const TSInsertRecordsOfOneDeviceReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertRecordsOfOneDeviceReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertRecordsOfOneDeviceReq &a, TSInsertRecordsOfOneDeviceReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertRecordsOfOneDeviceReq& obj);

typedef struct _TSInsertStringRecordsOfOneDeviceReq__isset {
  _TSInsertStringRecordsOfOneDeviceReq__isset() : isAligned(false) {}
  bool isAligned :1;
} _TSInsertStringRecordsOfOneDeviceReq__isset;

class TSInsertStringRecordsOfOneDeviceReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertStringRecordsOfOneDeviceReq(const TSInsertStringRecordsOfOneDeviceReq&);
  TSInsertStringRecordsOfOneDeviceReq& operator=(const TSInsertStringRecordsOfOneDeviceReq&);
  TSInsertStringRecordsOfOneDeviceReq() : sessionId(0), prefixPath(), isAligned(0) {
  }

  virtual ~TSInsertStringRecordsOfOneDeviceReq() noexcept;
  int64_t sessionId;
  std::string prefixPath;
  std::vector<std::vector<std::string> >  measurementsList;
  std::vector<std::vector<std::string> >  valuesList;
  std::vector<int64_t>  timestamps;
  bool isAligned;

  _TSInsertStringRecordsOfOneDeviceReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPath(const std::string& val);

  void __set_measurementsList(const std::vector<std::vector<std::string> > & val);

  void __set_valuesList(const std::vector<std::vector<std::string> > & val);

  void __set_timestamps(const std::vector<int64_t> & val);

  void __set_isAligned(const bool val);

  bool operator == (const TSInsertStringRecordsOfOneDeviceReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    if (!(measurementsList == rhs.measurementsList))
      return false;
    if (!(valuesList == rhs.valuesList))
      return false;
    if (!(timestamps == rhs.timestamps))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    return true;
  }
  bool operator != (const TSInsertStringRecordsOfOneDeviceReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertStringRecordsOfOneDeviceReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertStringRecordsOfOneDeviceReq &a, TSInsertStringRecordsOfOneDeviceReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordsOfOneDeviceReq& obj);

typedef struct _TSInsertStringRecordsReq__isset {
  _TSInsertStringRecordsReq__isset() : isAligned(false) {}
  bool isAligned :1;
} _TSInsertStringRecordsReq__isset;

class TSInsertStringRecordsReq : public virtual ::apache::thrift::TBase {
 public:

  TSInsertStringRecordsReq(const TSInsertStringRecordsReq&);
  TSInsertStringRecordsReq& operator=(const TSInsertStringRecordsReq&);
  TSInsertStringRecordsReq() : sessionId(0), isAligned(0) {
  }

  virtual ~TSInsertStringRecordsReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  prefixPaths;
  std::vector<std::vector<std::string> >  measurementsList;
  std::vector<std::vector<std::string> >  valuesList;
  std::vector<int64_t>  timestamps;
  bool isAligned;

  _TSInsertStringRecordsReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPaths(const std::vector<std::string> & val);

  void __set_measurementsList(const std::vector<std::vector<std::string> > & val);

  void __set_valuesList(const std::vector<std::vector<std::string> > & val);

  void __set_timestamps(const std::vector<int64_t> & val);

  void __set_isAligned(const bool val);

  bool operator == (const TSInsertStringRecordsReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPaths == rhs.prefixPaths))
      return false;
    if (!(measurementsList == rhs.measurementsList))
      return false;
    if (!(valuesList == rhs.valuesList))
      return false;
    if (!(timestamps == rhs.timestamps))
      return false;
    if (__isset.isAligned != rhs.__isset.isAligned)
      return false;
    else if (__isset.isAligned && !(isAligned == rhs.isAligned))
      return false;
    return true;
  }
  bool operator != (const TSInsertStringRecordsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSInsertStringRecordsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSInsertStringRecordsReq &a, TSInsertStringRecordsReq &b);

std::ostream& operator<<(std::ostream& out, const TSInsertStringRecordsReq& obj);


class TSDeleteDataReq : public virtual ::apache::thrift::TBase {
 public:

  TSDeleteDataReq(const TSDeleteDataReq&);
  TSDeleteDataReq& operator=(const TSDeleteDataReq&);
  TSDeleteDataReq() : sessionId(0), startTime(0), endTime(0) {
  }

  virtual ~TSDeleteDataReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  paths;
  int64_t startTime;
  int64_t endTime;

  void __set_sessionId(const int64_t val);

  void __set_paths(const std::vector<std::string> & val);

  void __set_startTime(const int64_t val);

  void __set_endTime(const int64_t val);

  bool operator == (const TSDeleteDataReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(paths == rhs.paths))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(endTime == rhs.endTime))
      return false;
    return true;
  }
  bool operator != (const TSDeleteDataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSDeleteDataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSDeleteDataReq &a, TSDeleteDataReq &b);

std::ostream& operator<<(std::ostream& out, const TSDeleteDataReq& obj);

typedef struct _TSCreateTimeseriesReq__isset {
  _TSCreateTimeseriesReq__isset() : props(false), tags(false), attributes(false), measurementAlias(false) {}
  bool props :1;
  bool tags :1;
  bool attributes :1;
  bool measurementAlias :1;
} _TSCreateTimeseriesReq__isset;

class TSCreateTimeseriesReq : public virtual ::apache::thrift::TBase {
 public:

  TSCreateTimeseriesReq(const TSCreateTimeseriesReq&);
  TSCreateTimeseriesReq& operator=(const TSCreateTimeseriesReq&);
  TSCreateTimeseriesReq() : sessionId(0), path(), dataType(0), encoding(0), compressor(0), measurementAlias() {
  }

  virtual ~TSCreateTimeseriesReq() noexcept;
  int64_t sessionId;
  std::string path;
  int32_t dataType;
  int32_t encoding;
  int32_t compressor;
  std::map<std::string, std::string>  props;
  std::map<std::string, std::string>  tags;
  std::map<std::string, std::string>  attributes;
  std::string measurementAlias;

  _TSCreateTimeseriesReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_path(const std::string& val);

  void __set_dataType(const int32_t val);

  void __set_encoding(const int32_t val);

  void __set_compressor(const int32_t val);

  void __set_props(const std::map<std::string, std::string> & val);

  void __set_tags(const std::map<std::string, std::string> & val);

  void __set_attributes(const std::map<std::string, std::string> & val);

  void __set_measurementAlias(const std::string& val);

  bool operator == (const TSCreateTimeseriesReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(dataType == rhs.dataType))
      return false;
    if (!(encoding == rhs.encoding))
      return false;
    if (!(compressor == rhs.compressor))
      return false;
    if (__isset.props != rhs.__isset.props)
      return false;
    else if (__isset.props && !(props == rhs.props))
      return false;
    if (__isset.tags != rhs.__isset.tags)
      return false;
    else if (__isset.tags && !(tags == rhs.tags))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.measurementAlias != rhs.__isset.measurementAlias)
      return false;
    else if (__isset.measurementAlias && !(measurementAlias == rhs.measurementAlias))
      return false;
    return true;
  }
  bool operator != (const TSCreateTimeseriesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSCreateTimeseriesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSCreateTimeseriesReq &a, TSCreateTimeseriesReq &b);

std::ostream& operator<<(std::ostream& out, const TSCreateTimeseriesReq& obj);

typedef struct _TSCreateAlignedTimeseriesReq__isset {
  _TSCreateAlignedTimeseriesReq__isset() : measurementAlias(false), tagsList(false), attributesList(false) {}
  bool measurementAlias :1;
  bool tagsList :1;
  bool attributesList :1;
} _TSCreateAlignedTimeseriesReq__isset;

class TSCreateAlignedTimeseriesReq : public virtual ::apache::thrift::TBase {
 public:

  TSCreateAlignedTimeseriesReq(const TSCreateAlignedTimeseriesReq&);
  TSCreateAlignedTimeseriesReq& operator=(const TSCreateAlignedTimeseriesReq&);
  TSCreateAlignedTimeseriesReq() : sessionId(0), prefixPath() {
  }

  virtual ~TSCreateAlignedTimeseriesReq() noexcept;
  int64_t sessionId;
  std::string prefixPath;
  std::vector<std::string>  measurements;
  std::vector<int32_t>  dataTypes;
  std::vector<int32_t>  encodings;
  std::vector<int32_t>  compressors;
  std::vector<std::string>  measurementAlias;
  std::vector<std::map<std::string, std::string> >  tagsList;
  std::vector<std::map<std::string, std::string> >  attributesList;

  _TSCreateAlignedTimeseriesReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_prefixPath(const std::string& val);

  void __set_measurements(const std::vector<std::string> & val);

  void __set_dataTypes(const std::vector<int32_t> & val);

  void __set_encodings(const std::vector<int32_t> & val);

  void __set_compressors(const std::vector<int32_t> & val);

  void __set_measurementAlias(const std::vector<std::string> & val);

  void __set_tagsList(const std::vector<std::map<std::string, std::string> > & val);

  void __set_attributesList(const std::vector<std::map<std::string, std::string> > & val);

  bool operator == (const TSCreateAlignedTimeseriesReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    if (!(measurements == rhs.measurements))
      return false;
    if (!(dataTypes == rhs.dataTypes))
      return false;
    if (!(encodings == rhs.encodings))
      return false;
    if (!(compressors == rhs.compressors))
      return false;
    if (__isset.measurementAlias != rhs.__isset.measurementAlias)
      return false;
    else if (__isset.measurementAlias && !(measurementAlias == rhs.measurementAlias))
      return false;
    if (__isset.tagsList != rhs.__isset.tagsList)
      return false;
    else if (__isset.tagsList && !(tagsList == rhs.tagsList))
      return false;
    if (__isset.attributesList != rhs.__isset.attributesList)
      return false;
    else if (__isset.attributesList && !(attributesList == rhs.attributesList))
      return false;
    return true;
  }
  bool operator != (const TSCreateAlignedTimeseriesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSCreateAlignedTimeseriesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSCreateAlignedTimeseriesReq &a, TSCreateAlignedTimeseriesReq &b);

std::ostream& operator<<(std::ostream& out, const TSCreateAlignedTimeseriesReq& obj);

typedef struct _TSRawDataQueryReq__isset {
  _TSRawDataQueryReq__isset() : fetchSize(false), enableRedirectQuery(false), jdbcQuery(false), timeout(false) {}
  bool fetchSize :1;
  bool enableRedirectQuery :1;
  bool jdbcQuery :1;
  bool timeout :1;
} _TSRawDataQueryReq__isset;

class TSRawDataQueryReq : public virtual ::apache::thrift::TBase {
 public:

  TSRawDataQueryReq(const TSRawDataQueryReq&);
  TSRawDataQueryReq& operator=(const TSRawDataQueryReq&);
  TSRawDataQueryReq() : sessionId(0), fetchSize(0), startTime(0), endTime(0), statementId(0), enableRedirectQuery(0), jdbcQuery(0), timeout(0) {
  }

  virtual ~TSRawDataQueryReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  paths;
  int32_t fetchSize;
  int64_t startTime;
  int64_t endTime;
  int64_t statementId;
  bool enableRedirectQuery;
  bool jdbcQuery;
  int64_t timeout;

  _TSRawDataQueryReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_paths(const std::vector<std::string> & val);

  void __set_fetchSize(const int32_t val);

  void __set_startTime(const int64_t val);

  void __set_endTime(const int64_t val);

  void __set_statementId(const int64_t val);

  void __set_enableRedirectQuery(const bool val);

  void __set_jdbcQuery(const bool val);

  void __set_timeout(const int64_t val);

  bool operator == (const TSRawDataQueryReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(paths == rhs.paths))
      return false;
    if (__isset.fetchSize != rhs.__isset.fetchSize)
      return false;
    else if (__isset.fetchSize && !(fetchSize == rhs.fetchSize))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(endTime == rhs.endTime))
      return false;
    if (!(statementId == rhs.statementId))
      return false;
    if (__isset.enableRedirectQuery != rhs.__isset.enableRedirectQuery)
      return false;
    else if (__isset.enableRedirectQuery && !(enableRedirectQuery == rhs.enableRedirectQuery))
      return false;
    if (__isset.jdbcQuery != rhs.__isset.jdbcQuery)
      return false;
    else if (__isset.jdbcQuery && !(jdbcQuery == rhs.jdbcQuery))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const TSRawDataQueryReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSRawDataQueryReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSRawDataQueryReq &a, TSRawDataQueryReq &b);

std::ostream& operator<<(std::ostream& out, const TSRawDataQueryReq& obj);

typedef struct _TSLastDataQueryReq__isset {
  _TSLastDataQueryReq__isset() : fetchSize(false), enableRedirectQuery(false), jdbcQuery(false), timeout(false) {}
  bool fetchSize :1;
  bool enableRedirectQuery :1;
  bool jdbcQuery :1;
  bool timeout :1;
} _TSLastDataQueryReq__isset;

class TSLastDataQueryReq : public virtual ::apache::thrift::TBase {
 public:

  TSLastDataQueryReq(const TSLastDataQueryReq&);
  TSLastDataQueryReq& operator=(const TSLastDataQueryReq&);
  TSLastDataQueryReq() : sessionId(0), fetchSize(0), time(0), statementId(0), enableRedirectQuery(0), jdbcQuery(0), timeout(0) {
  }

  virtual ~TSLastDataQueryReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  paths;
  int32_t fetchSize;
  int64_t time;
  int64_t statementId;
  bool enableRedirectQuery;
  bool jdbcQuery;
  int64_t timeout;

  _TSLastDataQueryReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_paths(const std::vector<std::string> & val);

  void __set_fetchSize(const int32_t val);

  void __set_time(const int64_t val);

  void __set_statementId(const int64_t val);

  void __set_enableRedirectQuery(const bool val);

  void __set_jdbcQuery(const bool val);

  void __set_timeout(const int64_t val);

  bool operator == (const TSLastDataQueryReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(paths == rhs.paths))
      return false;
    if (__isset.fetchSize != rhs.__isset.fetchSize)
      return false;
    else if (__isset.fetchSize && !(fetchSize == rhs.fetchSize))
      return false;
    if (!(time == rhs.time))
      return false;
    if (!(statementId == rhs.statementId))
      return false;
    if (__isset.enableRedirectQuery != rhs.__isset.enableRedirectQuery)
      return false;
    else if (__isset.enableRedirectQuery && !(enableRedirectQuery == rhs.enableRedirectQuery))
      return false;
    if (__isset.jdbcQuery != rhs.__isset.jdbcQuery)
      return false;
    else if (__isset.jdbcQuery && !(jdbcQuery == rhs.jdbcQuery))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const TSLastDataQueryReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSLastDataQueryReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSLastDataQueryReq &a, TSLastDataQueryReq &b);

std::ostream& operator<<(std::ostream& out, const TSLastDataQueryReq& obj);

typedef struct _TSCreateMultiTimeseriesReq__isset {
  _TSCreateMultiTimeseriesReq__isset() : propsList(false), tagsList(false), attributesList(false), measurementAliasList(false) {}
  bool propsList :1;
  bool tagsList :1;
  bool attributesList :1;
  bool measurementAliasList :1;
} _TSCreateMultiTimeseriesReq__isset;

class TSCreateMultiTimeseriesReq : public virtual ::apache::thrift::TBase {
 public:

  TSCreateMultiTimeseriesReq(const TSCreateMultiTimeseriesReq&);
  TSCreateMultiTimeseriesReq& operator=(const TSCreateMultiTimeseriesReq&);
  TSCreateMultiTimeseriesReq() : sessionId(0) {
  }

  virtual ~TSCreateMultiTimeseriesReq() noexcept;
  int64_t sessionId;
  std::vector<std::string>  paths;
  std::vector<int32_t>  dataTypes;
  std::vector<int32_t>  encodings;
  std::vector<int32_t>  compressors;
  std::vector<std::map<std::string, std::string> >  propsList;
  std::vector<std::map<std::string, std::string> >  tagsList;
  std::vector<std::map<std::string, std::string> >  attributesList;
  std::vector<std::string>  measurementAliasList;

  _TSCreateMultiTimeseriesReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_paths(const std::vector<std::string> & val);

  void __set_dataTypes(const std::vector<int32_t> & val);

  void __set_encodings(const std::vector<int32_t> & val);

  void __set_compressors(const std::vector<int32_t> & val);

  void __set_propsList(const std::vector<std::map<std::string, std::string> > & val);

  void __set_tagsList(const std::vector<std::map<std::string, std::string> > & val);

  void __set_attributesList(const std::vector<std::map<std::string, std::string> > & val);

  void __set_measurementAliasList(const std::vector<std::string> & val);

  bool operator == (const TSCreateMultiTimeseriesReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(paths == rhs.paths))
      return false;
    if (!(dataTypes == rhs.dataTypes))
      return false;
    if (!(encodings == rhs.encodings))
      return false;
    if (!(compressors == rhs.compressors))
      return false;
    if (__isset.propsList != rhs.__isset.propsList)
      return false;
    else if (__isset.propsList && !(propsList == rhs.propsList))
      return false;
    if (__isset.tagsList != rhs.__isset.tagsList)
      return false;
    else if (__isset.tagsList && !(tagsList == rhs.tagsList))
      return false;
    if (__isset.attributesList != rhs.__isset.attributesList)
      return false;
    else if (__isset.attributesList && !(attributesList == rhs.attributesList))
      return false;
    if (__isset.measurementAliasList != rhs.__isset.measurementAliasList)
      return false;
    else if (__isset.measurementAliasList && !(measurementAliasList == rhs.measurementAliasList))
      return false;
    return true;
  }
  bool operator != (const TSCreateMultiTimeseriesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSCreateMultiTimeseriesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSCreateMultiTimeseriesReq &a, TSCreateMultiTimeseriesReq &b);

std::ostream& operator<<(std::ostream& out, const TSCreateMultiTimeseriesReq& obj);

typedef struct _ServerProperties__isset {
  _ServerProperties__isset() : maxConcurrentClientNum(false), watermarkSecretKey(false), watermarkBitString(false), watermarkParamMarkRate(false), watermarkParamMaxRightBit(false), thriftMaxFrameSize(false), isReadOnly(false) {}
  bool maxConcurrentClientNum :1;
  bool watermarkSecretKey :1;
  bool watermarkBitString :1;
  bool watermarkParamMarkRate :1;
  bool watermarkParamMaxRightBit :1;
  bool thriftMaxFrameSize :1;
  bool isReadOnly :1;
} _ServerProperties__isset;

class ServerProperties : public virtual ::apache::thrift::TBase {
 public:

  ServerProperties(const ServerProperties&);
  ServerProperties& operator=(const ServerProperties&);
  ServerProperties() : version(), timestampPrecision(), maxConcurrentClientNum(0), watermarkSecretKey(), watermarkBitString(), watermarkParamMarkRate(0), watermarkParamMaxRightBit(0), thriftMaxFrameSize(0), isReadOnly(0) {
  }

  virtual ~ServerProperties() noexcept;
  std::string version;
  std::vector<std::string>  supportedTimeAggregationOperations;
  std::string timestampPrecision;
  int32_t maxConcurrentClientNum;
  std::string watermarkSecretKey;
  std::string watermarkBitString;
  int32_t watermarkParamMarkRate;
  int32_t watermarkParamMaxRightBit;
  int32_t thriftMaxFrameSize;
  bool isReadOnly;

  _ServerProperties__isset __isset;

  void __set_version(const std::string& val);

  void __set_supportedTimeAggregationOperations(const std::vector<std::string> & val);

  void __set_timestampPrecision(const std::string& val);

  void __set_maxConcurrentClientNum(const int32_t val);

  void __set_watermarkSecretKey(const std::string& val);

  void __set_watermarkBitString(const std::string& val);

  void __set_watermarkParamMarkRate(const int32_t val);

  void __set_watermarkParamMaxRightBit(const int32_t val);

  void __set_thriftMaxFrameSize(const int32_t val);

  void __set_isReadOnly(const bool val);

  bool operator == (const ServerProperties & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(supportedTimeAggregationOperations == rhs.supportedTimeAggregationOperations))
      return false;
    if (!(timestampPrecision == rhs.timestampPrecision))
      return false;
    if (!(maxConcurrentClientNum == rhs.maxConcurrentClientNum))
      return false;
    if (__isset.watermarkSecretKey != rhs.__isset.watermarkSecretKey)
      return false;
    else if (__isset.watermarkSecretKey && !(watermarkSecretKey == rhs.watermarkSecretKey))
      return false;
    if (__isset.watermarkBitString != rhs.__isset.watermarkBitString)
      return false;
    else if (__isset.watermarkBitString && !(watermarkBitString == rhs.watermarkBitString))
      return false;
    if (__isset.watermarkParamMarkRate != rhs.__isset.watermarkParamMarkRate)
      return false;
    else if (__isset.watermarkParamMarkRate && !(watermarkParamMarkRate == rhs.watermarkParamMarkRate))
      return false;
    if (__isset.watermarkParamMaxRightBit != rhs.__isset.watermarkParamMaxRightBit)
      return false;
    else if (__isset.watermarkParamMaxRightBit && !(watermarkParamMaxRightBit == rhs.watermarkParamMaxRightBit))
      return false;
    if (__isset.thriftMaxFrameSize != rhs.__isset.thriftMaxFrameSize)
      return false;
    else if (__isset.thriftMaxFrameSize && !(thriftMaxFrameSize == rhs.thriftMaxFrameSize))
      return false;
    if (__isset.isReadOnly != rhs.__isset.isReadOnly)
      return false;
    else if (__isset.isReadOnly && !(isReadOnly == rhs.isReadOnly))
      return false;
    return true;
  }
  bool operator != (const ServerProperties &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServerProperties & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ServerProperties &a, ServerProperties &b);

std::ostream& operator<<(std::ostream& out, const ServerProperties& obj);


class TSSetSchemaTemplateReq : public virtual ::apache::thrift::TBase {
 public:

  TSSetSchemaTemplateReq(const TSSetSchemaTemplateReq&);
  TSSetSchemaTemplateReq& operator=(const TSSetSchemaTemplateReq&);
  TSSetSchemaTemplateReq() : sessionId(0), templateName(), prefixPath() {
  }

  virtual ~TSSetSchemaTemplateReq() noexcept;
  int64_t sessionId;
  std::string templateName;
  std::string prefixPath;

  void __set_sessionId(const int64_t val);

  void __set_templateName(const std::string& val);

  void __set_prefixPath(const std::string& val);

  bool operator == (const TSSetSchemaTemplateReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(templateName == rhs.templateName))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    return true;
  }
  bool operator != (const TSSetSchemaTemplateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSSetSchemaTemplateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSSetSchemaTemplateReq &a, TSSetSchemaTemplateReq &b);

std::ostream& operator<<(std::ostream& out, const TSSetSchemaTemplateReq& obj);


class TSCreateSchemaTemplateReq : public virtual ::apache::thrift::TBase {
 public:

  TSCreateSchemaTemplateReq(const TSCreateSchemaTemplateReq&);
  TSCreateSchemaTemplateReq& operator=(const TSCreateSchemaTemplateReq&);
  TSCreateSchemaTemplateReq() : sessionId(0), name(), serializedTemplate() {
  }

  virtual ~TSCreateSchemaTemplateReq() noexcept;
  int64_t sessionId;
  std::string name;
  std::string serializedTemplate;

  void __set_sessionId(const int64_t val);

  void __set_name(const std::string& val);

  void __set_serializedTemplate(const std::string& val);

  bool operator == (const TSCreateSchemaTemplateReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(serializedTemplate == rhs.serializedTemplate))
      return false;
    return true;
  }
  bool operator != (const TSCreateSchemaTemplateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSCreateSchemaTemplateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSCreateSchemaTemplateReq &a, TSCreateSchemaTemplateReq &b);

std::ostream& operator<<(std::ostream& out, const TSCreateSchemaTemplateReq& obj);


class TSAppendSchemaTemplateReq : public virtual ::apache::thrift::TBase {
 public:

  TSAppendSchemaTemplateReq(const TSAppendSchemaTemplateReq&);
  TSAppendSchemaTemplateReq& operator=(const TSAppendSchemaTemplateReq&);
  TSAppendSchemaTemplateReq() : sessionId(0), name(), isAligned(0) {
  }

  virtual ~TSAppendSchemaTemplateReq() noexcept;
  int64_t sessionId;
  std::string name;
  bool isAligned;
  std::vector<std::string>  measurements;
  std::vector<int32_t>  dataTypes;
  std::vector<int32_t>  encodings;
  std::vector<int32_t>  compressors;

  void __set_sessionId(const int64_t val);

  void __set_name(const std::string& val);

  void __set_isAligned(const bool val);

  void __set_measurements(const std::vector<std::string> & val);

  void __set_dataTypes(const std::vector<int32_t> & val);

  void __set_encodings(const std::vector<int32_t> & val);

  void __set_compressors(const std::vector<int32_t> & val);

  bool operator == (const TSAppendSchemaTemplateReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(isAligned == rhs.isAligned))
      return false;
    if (!(measurements == rhs.measurements))
      return false;
    if (!(dataTypes == rhs.dataTypes))
      return false;
    if (!(encodings == rhs.encodings))
      return false;
    if (!(compressors == rhs.compressors))
      return false;
    return true;
  }
  bool operator != (const TSAppendSchemaTemplateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSAppendSchemaTemplateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSAppendSchemaTemplateReq &a, TSAppendSchemaTemplateReq &b);

std::ostream& operator<<(std::ostream& out, const TSAppendSchemaTemplateReq& obj);

typedef struct _TSPhysicalPlanReq__isset {
  _TSPhysicalPlanReq__isset() : version(false) {}
  bool version :1;
} _TSPhysicalPlanReq__isset;

class TSPhysicalPlanReq : public virtual ::apache::thrift::TBase {
 public:

  TSPhysicalPlanReq(const TSPhysicalPlanReq&);
  TSPhysicalPlanReq& operator=(const TSPhysicalPlanReq&);
  TSPhysicalPlanReq() : version(), planBytes() {
  }

  virtual ~TSPhysicalPlanReq() noexcept;
  std::string version;
  std::string planBytes;

  _TSPhysicalPlanReq__isset __isset;

  void __set_version(const std::string& val);

  void __set_planBytes(const std::string& val);

  bool operator == (const TSPhysicalPlanReq & rhs) const
  {
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (!(planBytes == rhs.planBytes))
      return false;
    return true;
  }
  bool operator != (const TSPhysicalPlanReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSPhysicalPlanReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSPhysicalPlanReq &a, TSPhysicalPlanReq &b);

std::ostream& operator<<(std::ostream& out, const TSPhysicalPlanReq& obj);

typedef struct _TSNodeStatusReq__isset {
  _TSNodeStatusReq__isset() : version(false), needWalDirMaxSize(false), needWalDirSize(false), needWalPartitionFreeSize(false), needRpcDelay(false), needWritePoolsQueueSize(false), needReadPoolsQueueSize(false), needReplicationRunningStatus(false) {}
  bool version :1;
  bool needWalDirMaxSize :1;
  bool needWalDirSize :1;
  bool needWalPartitionFreeSize :1;
  bool needRpcDelay :1;
  bool needWritePoolsQueueSize :1;
  bool needReadPoolsQueueSize :1;
  bool needReplicationRunningStatus :1;
} _TSNodeStatusReq__isset;

class TSNodeStatusReq : public virtual ::apache::thrift::TBase {
 public:

  TSNodeStatusReq(const TSNodeStatusReq&);
  TSNodeStatusReq& operator=(const TSNodeStatusReq&);
  TSNodeStatusReq() : version(), needWalDirMaxSize(0), needWalDirSize(0), needWalPartitionFreeSize(0), needRpcDelay(0), needWritePoolsQueueSize(0), needReadPoolsQueueSize(0), needReplicationRunningStatus(0) {
  }

  virtual ~TSNodeStatusReq() noexcept;
  std::string version;
  bool needWalDirMaxSize;
  bool needWalDirSize;
  bool needWalPartitionFreeSize;
  bool needRpcDelay;
  bool needWritePoolsQueueSize;
  bool needReadPoolsQueueSize;
  bool needReplicationRunningStatus;

  _TSNodeStatusReq__isset __isset;

  void __set_version(const std::string& val);

  void __set_needWalDirMaxSize(const bool val);

  void __set_needWalDirSize(const bool val);

  void __set_needWalPartitionFreeSize(const bool val);

  void __set_needRpcDelay(const bool val);

  void __set_needWritePoolsQueueSize(const bool val);

  void __set_needReadPoolsQueueSize(const bool val);

  void __set_needReplicationRunningStatus(const bool val);

  bool operator == (const TSNodeStatusReq & rhs) const
  {
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.needWalDirMaxSize != rhs.__isset.needWalDirMaxSize)
      return false;
    else if (__isset.needWalDirMaxSize && !(needWalDirMaxSize == rhs.needWalDirMaxSize))
      return false;
    if (__isset.needWalDirSize != rhs.__isset.needWalDirSize)
      return false;
    else if (__isset.needWalDirSize && !(needWalDirSize == rhs.needWalDirSize))
      return false;
    if (__isset.needWalPartitionFreeSize != rhs.__isset.needWalPartitionFreeSize)
      return false;
    else if (__isset.needWalPartitionFreeSize && !(needWalPartitionFreeSize == rhs.needWalPartitionFreeSize))
      return false;
    if (__isset.needRpcDelay != rhs.__isset.needRpcDelay)
      return false;
    else if (__isset.needRpcDelay && !(needRpcDelay == rhs.needRpcDelay))
      return false;
    if (__isset.needWritePoolsQueueSize != rhs.__isset.needWritePoolsQueueSize)
      return false;
    else if (__isset.needWritePoolsQueueSize && !(needWritePoolsQueueSize == rhs.needWritePoolsQueueSize))
      return false;
    if (__isset.needReadPoolsQueueSize != rhs.__isset.needReadPoolsQueueSize)
      return false;
    else if (__isset.needReadPoolsQueueSize && !(needReadPoolsQueueSize == rhs.needReadPoolsQueueSize))
      return false;
    if (__isset.needReplicationRunningStatus != rhs.__isset.needReplicationRunningStatus)
      return false;
    else if (__isset.needReplicationRunningStatus && !(needReplicationRunningStatus == rhs.needReplicationRunningStatus))
      return false;
    return true;
  }
  bool operator != (const TSNodeStatusReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSNodeStatusReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSNodeStatusReq &a, TSNodeStatusReq &b);

std::ostream& operator<<(std::ostream& out, const TSNodeStatusReq& obj);

typedef struct _TSNodeStatusResp__isset {
  _TSNodeStatusResp__isset() : version(false), walDirMaxSizeMB(false), walDirSizeMB(false), walPartitionFreeMB(false), rpcDelay(false), writePoolsQueueSizeStr(false), readPoolsQueueSizeStr(false), replicationRunning(false) {}
  bool version :1;
  bool walDirMaxSizeMB :1;
  bool walDirSizeMB :1;
  bool walPartitionFreeMB :1;
  bool rpcDelay :1;
  bool writePoolsQueueSizeStr :1;
  bool readPoolsQueueSizeStr :1;
  bool replicationRunning :1;
} _TSNodeStatusResp__isset;

class TSNodeStatusResp : public virtual ::apache::thrift::TBase {
 public:

  TSNodeStatusResp(const TSNodeStatusResp&);
  TSNodeStatusResp& operator=(const TSNodeStatusResp&);
  TSNodeStatusResp() : version(), walDirMaxSizeMB(0), walDirSizeMB(0), walPartitionFreeMB(0), rpcDelay(0), writePoolsQueueSizeStr(), readPoolsQueueSizeStr(), replicationRunning(0) {
  }

  virtual ~TSNodeStatusResp() noexcept;
  std::string version;
   ::TSStatus status;
  int64_t walDirMaxSizeMB;
  int64_t walDirSizeMB;
  int64_t walPartitionFreeMB;
  int64_t rpcDelay;
  std::string writePoolsQueueSizeStr;
  std::string readPoolsQueueSizeStr;
  bool replicationRunning;

  _TSNodeStatusResp__isset __isset;

  void __set_version(const std::string& val);

  void __set_status(const  ::TSStatus& val);

  void __set_walDirMaxSizeMB(const int64_t val);

  void __set_walDirSizeMB(const int64_t val);

  void __set_walPartitionFreeMB(const int64_t val);

  void __set_rpcDelay(const int64_t val);

  void __set_writePoolsQueueSizeStr(const std::string& val);

  void __set_readPoolsQueueSizeStr(const std::string& val);

  void __set_replicationRunning(const bool val);

  bool operator == (const TSNodeStatusResp & rhs) const
  {
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (!(status == rhs.status))
      return false;
    if (__isset.walDirMaxSizeMB != rhs.__isset.walDirMaxSizeMB)
      return false;
    else if (__isset.walDirMaxSizeMB && !(walDirMaxSizeMB == rhs.walDirMaxSizeMB))
      return false;
    if (__isset.walDirSizeMB != rhs.__isset.walDirSizeMB)
      return false;
    else if (__isset.walDirSizeMB && !(walDirSizeMB == rhs.walDirSizeMB))
      return false;
    if (__isset.walPartitionFreeMB != rhs.__isset.walPartitionFreeMB)
      return false;
    else if (__isset.walPartitionFreeMB && !(walPartitionFreeMB == rhs.walPartitionFreeMB))
      return false;
    if (__isset.rpcDelay != rhs.__isset.rpcDelay)
      return false;
    else if (__isset.rpcDelay && !(rpcDelay == rhs.rpcDelay))
      return false;
    if (__isset.writePoolsQueueSizeStr != rhs.__isset.writePoolsQueueSizeStr)
      return false;
    else if (__isset.writePoolsQueueSizeStr && !(writePoolsQueueSizeStr == rhs.writePoolsQueueSizeStr))
      return false;
    if (__isset.readPoolsQueueSizeStr != rhs.__isset.readPoolsQueueSizeStr)
      return false;
    else if (__isset.readPoolsQueueSizeStr && !(readPoolsQueueSizeStr == rhs.readPoolsQueueSizeStr))
      return false;
    if (__isset.replicationRunning != rhs.__isset.replicationRunning)
      return false;
    else if (__isset.replicationRunning && !(replicationRunning == rhs.replicationRunning))
      return false;
    return true;
  }
  bool operator != (const TSNodeStatusResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSNodeStatusResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSNodeStatusResp &a, TSNodeStatusResp &b);

std::ostream& operator<<(std::ostream& out, const TSNodeStatusResp& obj);


class TSPruneSchemaTemplateReq : public virtual ::apache::thrift::TBase {
 public:

  TSPruneSchemaTemplateReq(const TSPruneSchemaTemplateReq&);
  TSPruneSchemaTemplateReq& operator=(const TSPruneSchemaTemplateReq&);
  TSPruneSchemaTemplateReq() : sessionId(0), name(), path() {
  }

  virtual ~TSPruneSchemaTemplateReq() noexcept;
  int64_t sessionId;
  std::string name;
  std::string path;

  void __set_sessionId(const int64_t val);

  void __set_name(const std::string& val);

  void __set_path(const std::string& val);

  bool operator == (const TSPruneSchemaTemplateReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const TSPruneSchemaTemplateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSPruneSchemaTemplateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSPruneSchemaTemplateReq &a, TSPruneSchemaTemplateReq &b);

std::ostream& operator<<(std::ostream& out, const TSPruneSchemaTemplateReq& obj);

typedef struct _TSQueryTemplateReq__isset {
  _TSQueryTemplateReq__isset() : measurement(false) {}
  bool measurement :1;
} _TSQueryTemplateReq__isset;

class TSQueryTemplateReq : public virtual ::apache::thrift::TBase {
 public:

  TSQueryTemplateReq(const TSQueryTemplateReq&);
  TSQueryTemplateReq& operator=(const TSQueryTemplateReq&);
  TSQueryTemplateReq() : sessionId(0), name(), queryType(0), measurement() {
  }

  virtual ~TSQueryTemplateReq() noexcept;
  int64_t sessionId;
  std::string name;
  int32_t queryType;
  std::string measurement;

  _TSQueryTemplateReq__isset __isset;

  void __set_sessionId(const int64_t val);

  void __set_name(const std::string& val);

  void __set_queryType(const int32_t val);

  void __set_measurement(const std::string& val);

  bool operator == (const TSQueryTemplateReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(queryType == rhs.queryType))
      return false;
    if (__isset.measurement != rhs.__isset.measurement)
      return false;
    else if (__isset.measurement && !(measurement == rhs.measurement))
      return false;
    return true;
  }
  bool operator != (const TSQueryTemplateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSQueryTemplateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSQueryTemplateReq &a, TSQueryTemplateReq &b);

std::ostream& operator<<(std::ostream& out, const TSQueryTemplateReq& obj);

typedef struct _TSQueryTemplateResp__isset {
  _TSQueryTemplateResp__isset() : result(false), count(false), measurements(false) {}
  bool result :1;
  bool count :1;
  bool measurements :1;
} _TSQueryTemplateResp__isset;

class TSQueryTemplateResp : public virtual ::apache::thrift::TBase {
 public:

  TSQueryTemplateResp(const TSQueryTemplateResp&);
  TSQueryTemplateResp& operator=(const TSQueryTemplateResp&);
  TSQueryTemplateResp() : queryType(0), result(0), count(0) {
  }

  virtual ~TSQueryTemplateResp() noexcept;
   ::TSStatus status;
  int32_t queryType;
  bool result;
  int32_t count;
  std::vector<std::string>  measurements;

  _TSQueryTemplateResp__isset __isset;

  void __set_status(const  ::TSStatus& val);

  void __set_queryType(const int32_t val);

  void __set_result(const bool val);

  void __set_count(const int32_t val);

  void __set_measurements(const std::vector<std::string> & val);

  bool operator == (const TSQueryTemplateResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(queryType == rhs.queryType))
      return false;
    if (__isset.result != rhs.__isset.result)
      return false;
    else if (__isset.result && !(result == rhs.result))
      return false;
    if (__isset.count != rhs.__isset.count)
      return false;
    else if (__isset.count && !(count == rhs.count))
      return false;
    if (__isset.measurements != rhs.__isset.measurements)
      return false;
    else if (__isset.measurements && !(measurements == rhs.measurements))
      return false;
    return true;
  }
  bool operator != (const TSQueryTemplateResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSQueryTemplateResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSQueryTemplateResp &a, TSQueryTemplateResp &b);

std::ostream& operator<<(std::ostream& out, const TSQueryTemplateResp& obj);


class TSUnsetSchemaTemplateReq : public virtual ::apache::thrift::TBase {
 public:

  TSUnsetSchemaTemplateReq(const TSUnsetSchemaTemplateReq&);
  TSUnsetSchemaTemplateReq& operator=(const TSUnsetSchemaTemplateReq&);
  TSUnsetSchemaTemplateReq() : sessionId(0), prefixPath(), templateName() {
  }

  virtual ~TSUnsetSchemaTemplateReq() noexcept;
  int64_t sessionId;
  std::string prefixPath;
  std::string templateName;

  void __set_sessionId(const int64_t val);

  void __set_prefixPath(const std::string& val);

  void __set_templateName(const std::string& val);

  bool operator == (const TSUnsetSchemaTemplateReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(prefixPath == rhs.prefixPath))
      return false;
    if (!(templateName == rhs.templateName))
      return false;
    return true;
  }
  bool operator != (const TSUnsetSchemaTemplateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSUnsetSchemaTemplateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSUnsetSchemaTemplateReq &a, TSUnsetSchemaTemplateReq &b);

std::ostream& operator<<(std::ostream& out, const TSUnsetSchemaTemplateReq& obj);


class TSDropSchemaTemplateReq : public virtual ::apache::thrift::TBase {
 public:

  TSDropSchemaTemplateReq(const TSDropSchemaTemplateReq&);
  TSDropSchemaTemplateReq& operator=(const TSDropSchemaTemplateReq&);
  TSDropSchemaTemplateReq() : sessionId(0), templateName() {
  }

  virtual ~TSDropSchemaTemplateReq() noexcept;
  int64_t sessionId;
  std::string templateName;

  void __set_sessionId(const int64_t val);

  void __set_templateName(const std::string& val);

  bool operator == (const TSDropSchemaTemplateReq & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    if (!(templateName == rhs.templateName))
      return false;
    return true;
  }
  bool operator != (const TSDropSchemaTemplateReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSDropSchemaTemplateReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSDropSchemaTemplateReq &a, TSDropSchemaTemplateReq &b);

std::ostream& operator<<(std::ostream& out, const TSDropSchemaTemplateReq& obj);


class TSyncIdentityInfo : public virtual ::apache::thrift::TBase {
 public:

  TSyncIdentityInfo(const TSyncIdentityInfo&);
  TSyncIdentityInfo& operator=(const TSyncIdentityInfo&);
  TSyncIdentityInfo() : address(), pipeName(), createTime(0), version() {
  }

  virtual ~TSyncIdentityInfo() noexcept;
  std::string address;
  std::string pipeName;
  int64_t createTime;
  std::string version;

  void __set_address(const std::string& val);

  void __set_pipeName(const std::string& val);

  void __set_createTime(const int64_t val);

  void __set_version(const std::string& val);

  bool operator == (const TSyncIdentityInfo & rhs) const
  {
    if (!(address == rhs.address))
      return false;
    if (!(pipeName == rhs.pipeName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const TSyncIdentityInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSyncIdentityInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSyncIdentityInfo &a, TSyncIdentityInfo &b);

std::ostream& operator<<(std::ostream& out, const TSyncIdentityInfo& obj);


class TSyncTransportMetaInfo : public virtual ::apache::thrift::TBase {
 public:

  TSyncTransportMetaInfo(const TSyncTransportMetaInfo&);
  TSyncTransportMetaInfo& operator=(const TSyncTransportMetaInfo&);
  TSyncTransportMetaInfo() : fileName(), startIndex(0) {
  }

  virtual ~TSyncTransportMetaInfo() noexcept;
  std::string fileName;
  int64_t startIndex;

  void __set_fileName(const std::string& val);

  void __set_startIndex(const int64_t val);

  bool operator == (const TSyncTransportMetaInfo & rhs) const
  {
    if (!(fileName == rhs.fileName))
      return false;
    if (!(startIndex == rhs.startIndex))
      return false;
    return true;
  }
  bool operator != (const TSyncTransportMetaInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSyncTransportMetaInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSyncTransportMetaInfo &a, TSyncTransportMetaInfo &b);

std::ostream& operator<<(std::ostream& out, const TSyncTransportMetaInfo& obj);



#endif
