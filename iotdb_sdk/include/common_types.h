/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef common_TYPES_H
#define common_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>




struct TConsensusGroupType {
  enum type {
    ConfigRegion = 0,
    DataRegion = 1,
    SchemaRegion = 2
  };
};

extern const std::map<int, const char*> _TConsensusGroupType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TConsensusGroupType::type& val);

std::string to_string(const TConsensusGroupType::type& val);

struct TRegionMigrateFailedType {
  enum type {
    AddPeerFailed = 0,
    RemovePeerFailed = 1,
    RemoveConsensusGroupFailed = 2,
    DeleteRegionFailed = 3,
    CreateRegionFailed = 4
  };
};

extern const std::map<int, const char*> _TRegionMigrateFailedType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRegionMigrateFailedType::type& val);

std::string to_string(const TRegionMigrateFailedType::type& val);

struct TAggregationType {
  enum type {
    COUNT = 0,
    AVG = 1,
    SUM = 2,
    FIRST_VALUE = 3,
    LAST_VALUE = 4,
    MAX_TIME = 5,
    MIN_TIME = 6,
    MAX_VALUE = 7,
    MIN_VALUE = 8,
    EXTREME = 9,
    COUNT_IF = 10,
    TIME_DURATION = 11,
    MODE = 12
  };
};

extern const std::map<int, const char*> _TAggregationType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAggregationType::type& val);

std::string to_string(const TAggregationType::type& val);

struct TrainingState {
  enum type {
    PENDING = 0,
    RUNNING = 1,
    FINISHED = 2,
    FAILED = 3,
    DROPPING = 4
  };
};

extern const std::map<int, const char*> _TrainingState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TrainingState::type& val);

std::string to_string(const TrainingState::type& val);

struct ModelTask {
  enum type {
    FORECAST = 0
  };
};

extern const std::map<int, const char*> _ModelTask_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ModelTask::type& val);

std::string to_string(const ModelTask::type& val);

struct EvaluateMetric {
  enum type {
    MSE = 0,
    MAE = 1,
    RMSE = 2
  };
};

extern const std::map<int, const char*> _EvaluateMetric_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const EvaluateMetric::type& val);

std::string to_string(const EvaluateMetric::type& val);

class TEndPoint;

class TSStatus;

class TConsensusGroupId;

class TSeriesPartitionSlot;

class TTimePartitionSlot;

class TRegionReplicaSet;

class TNodeResource;

class TConfigNodeLocation;

class TDataNodeLocation;

class TDataNodeConfiguration;

class TFlushReq;

class TSettleReq;

class TSchemaNode;

class TSetTTLReq;

class TFile;

class TFilesResp;


class TEndPoint : public virtual ::apache::thrift::TBase {
 public:

  TEndPoint(const TEndPoint&);
  TEndPoint& operator=(const TEndPoint&);
  TEndPoint() : ip(), port(0) {
  }

  virtual ~TEndPoint() noexcept;
  std::string ip;
  int32_t port;

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  bool operator == (const TEndPoint & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const TEndPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEndPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEndPoint &a, TEndPoint &b);

std::ostream& operator<<(std::ostream& out, const TEndPoint& obj);

typedef struct _TSStatus__isset {
  _TSStatus__isset() : message(false), subStatus(false), redirectNode(false) {}
  bool message :1;
  bool subStatus :1;
  bool redirectNode :1;
} _TSStatus__isset;

class TSStatus : public virtual ::apache::thrift::TBase {
 public:

  TSStatus(const TSStatus&);
  TSStatus& operator=(const TSStatus&);
  TSStatus() : code(0), message() {
  }

  virtual ~TSStatus() noexcept;
  int32_t code;
  std::string message;
  std::vector<TSStatus>  subStatus;
  TEndPoint redirectNode;

  _TSStatus__isset __isset;

  void __set_code(const int32_t val);

  void __set_message(const std::string& val);

  void __set_subStatus(const std::vector<TSStatus> & val);

  void __set_redirectNode(const TEndPoint& val);

  bool operator == (const TSStatus & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.subStatus != rhs.__isset.subStatus)
      return false;
    else if (__isset.subStatus && !(subStatus == rhs.subStatus))
      return false;
    if (__isset.redirectNode != rhs.__isset.redirectNode)
      return false;
    else if (__isset.redirectNode && !(redirectNode == rhs.redirectNode))
      return false;
    return true;
  }
  bool operator != (const TSStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSStatus &a, TSStatus &b);

std::ostream& operator<<(std::ostream& out, const TSStatus& obj);


class TConsensusGroupId : public virtual ::apache::thrift::TBase {
 public:

  TConsensusGroupId(const TConsensusGroupId&);
  TConsensusGroupId& operator=(const TConsensusGroupId&);
  TConsensusGroupId() : type((TConsensusGroupType::type)0), id(0) {
  }

  virtual ~TConsensusGroupId() noexcept;
  /**
   * 
   * @see TConsensusGroupType
   */
  TConsensusGroupType::type type;
  int32_t id;

  void __set_type(const TConsensusGroupType::type val);

  void __set_id(const int32_t val);

  bool operator == (const TConsensusGroupId & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TConsensusGroupId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TConsensusGroupId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TConsensusGroupId &a, TConsensusGroupId &b);

std::ostream& operator<<(std::ostream& out, const TConsensusGroupId& obj);


class TSeriesPartitionSlot : public virtual ::apache::thrift::TBase {
 public:

  TSeriesPartitionSlot(const TSeriesPartitionSlot&);
  TSeriesPartitionSlot& operator=(const TSeriesPartitionSlot&);
  TSeriesPartitionSlot() : slotId(0) {
  }

  virtual ~TSeriesPartitionSlot() noexcept;
  int32_t slotId;

  void __set_slotId(const int32_t val);

  bool operator == (const TSeriesPartitionSlot & rhs) const
  {
    if (!(slotId == rhs.slotId))
      return false;
    return true;
  }
  bool operator != (const TSeriesPartitionSlot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSeriesPartitionSlot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSeriesPartitionSlot &a, TSeriesPartitionSlot &b);

std::ostream& operator<<(std::ostream& out, const TSeriesPartitionSlot& obj);


class TTimePartitionSlot : public virtual ::apache::thrift::TBase {
 public:

  TTimePartitionSlot(const TTimePartitionSlot&);
  TTimePartitionSlot& operator=(const TTimePartitionSlot&);
  TTimePartitionSlot() : startTime(0) {
  }

  virtual ~TTimePartitionSlot() noexcept;
  int64_t startTime;

  void __set_startTime(const int64_t val);

  bool operator == (const TTimePartitionSlot & rhs) const
  {
    if (!(startTime == rhs.startTime))
      return false;
    return true;
  }
  bool operator != (const TTimePartitionSlot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTimePartitionSlot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTimePartitionSlot &a, TTimePartitionSlot &b);

std::ostream& operator<<(std::ostream& out, const TTimePartitionSlot& obj);


class TRegionReplicaSet : public virtual ::apache::thrift::TBase {
 public:

  TRegionReplicaSet(const TRegionReplicaSet&);
  TRegionReplicaSet& operator=(const TRegionReplicaSet&);
  TRegionReplicaSet() {
  }

  virtual ~TRegionReplicaSet() noexcept;
  TConsensusGroupId regionId;
  std::vector<TDataNodeLocation>  dataNodeLocations;

  void __set_regionId(const TConsensusGroupId& val);

  void __set_dataNodeLocations(const std::vector<TDataNodeLocation> & val);

  bool operator == (const TRegionReplicaSet & rhs) const
  {
    if (!(regionId == rhs.regionId))
      return false;
    if (!(dataNodeLocations == rhs.dataNodeLocations))
      return false;
    return true;
  }
  bool operator != (const TRegionReplicaSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRegionReplicaSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRegionReplicaSet &a, TRegionReplicaSet &b);

std::ostream& operator<<(std::ostream& out, const TRegionReplicaSet& obj);


class TNodeResource : public virtual ::apache::thrift::TBase {
 public:

  TNodeResource(const TNodeResource&);
  TNodeResource& operator=(const TNodeResource&);
  TNodeResource() : cpuCoreNum(0), maxMemory(0) {
  }

  virtual ~TNodeResource() noexcept;
  int32_t cpuCoreNum;
  int64_t maxMemory;

  void __set_cpuCoreNum(const int32_t val);

  void __set_maxMemory(const int64_t val);

  bool operator == (const TNodeResource & rhs) const
  {
    if (!(cpuCoreNum == rhs.cpuCoreNum))
      return false;
    if (!(maxMemory == rhs.maxMemory))
      return false;
    return true;
  }
  bool operator != (const TNodeResource &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TNodeResource & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TNodeResource &a, TNodeResource &b);

std::ostream& operator<<(std::ostream& out, const TNodeResource& obj);


class TConfigNodeLocation : public virtual ::apache::thrift::TBase {
 public:

  TConfigNodeLocation(const TConfigNodeLocation&);
  TConfigNodeLocation& operator=(const TConfigNodeLocation&);
  TConfigNodeLocation() : configNodeId(0) {
  }

  virtual ~TConfigNodeLocation() noexcept;
  int32_t configNodeId;
  TEndPoint internalEndPoint;
  TEndPoint consensusEndPoint;

  void __set_configNodeId(const int32_t val);

  void __set_internalEndPoint(const TEndPoint& val);

  void __set_consensusEndPoint(const TEndPoint& val);

  bool operator == (const TConfigNodeLocation & rhs) const
  {
    if (!(configNodeId == rhs.configNodeId))
      return false;
    if (!(internalEndPoint == rhs.internalEndPoint))
      return false;
    if (!(consensusEndPoint == rhs.consensusEndPoint))
      return false;
    return true;
  }
  bool operator != (const TConfigNodeLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TConfigNodeLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TConfigNodeLocation &a, TConfigNodeLocation &b);

std::ostream& operator<<(std::ostream& out, const TConfigNodeLocation& obj);


class TDataNodeLocation : public virtual ::apache::thrift::TBase {
 public:

  TDataNodeLocation(const TDataNodeLocation&);
  TDataNodeLocation& operator=(const TDataNodeLocation&);
  TDataNodeLocation() : dataNodeId(0) {
  }

  virtual ~TDataNodeLocation() noexcept;
  int32_t dataNodeId;
  TEndPoint clientRpcEndPoint;
  TEndPoint internalEndPoint;
  TEndPoint mPPDataExchangeEndPoint;
  TEndPoint dataRegionConsensusEndPoint;
  TEndPoint schemaRegionConsensusEndPoint;

  void __set_dataNodeId(const int32_t val);

  void __set_clientRpcEndPoint(const TEndPoint& val);

  void __set_internalEndPoint(const TEndPoint& val);

  void __set_mPPDataExchangeEndPoint(const TEndPoint& val);

  void __set_dataRegionConsensusEndPoint(const TEndPoint& val);

  void __set_schemaRegionConsensusEndPoint(const TEndPoint& val);

  bool operator == (const TDataNodeLocation & rhs) const
  {
    if (!(dataNodeId == rhs.dataNodeId))
      return false;
    if (!(clientRpcEndPoint == rhs.clientRpcEndPoint))
      return false;
    if (!(internalEndPoint == rhs.internalEndPoint))
      return false;
    if (!(mPPDataExchangeEndPoint == rhs.mPPDataExchangeEndPoint))
      return false;
    if (!(dataRegionConsensusEndPoint == rhs.dataRegionConsensusEndPoint))
      return false;
    if (!(schemaRegionConsensusEndPoint == rhs.schemaRegionConsensusEndPoint))
      return false;
    return true;
  }
  bool operator != (const TDataNodeLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataNodeLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataNodeLocation &a, TDataNodeLocation &b);

std::ostream& operator<<(std::ostream& out, const TDataNodeLocation& obj);


class TDataNodeConfiguration : public virtual ::apache::thrift::TBase {
 public:

  TDataNodeConfiguration(const TDataNodeConfiguration&);
  TDataNodeConfiguration& operator=(const TDataNodeConfiguration&);
  TDataNodeConfiguration() {
  }

  virtual ~TDataNodeConfiguration() noexcept;
  TDataNodeLocation location;
  TNodeResource resource;

  void __set_location(const TDataNodeLocation& val);

  void __set_resource(const TNodeResource& val);

  bool operator == (const TDataNodeConfiguration & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    if (!(resource == rhs.resource))
      return false;
    return true;
  }
  bool operator != (const TDataNodeConfiguration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataNodeConfiguration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataNodeConfiguration &a, TDataNodeConfiguration &b);

std::ostream& operator<<(std::ostream& out, const TDataNodeConfiguration& obj);

typedef struct _TFlushReq__isset {
  _TFlushReq__isset() : isSeq(false), storageGroups(false) {}
  bool isSeq :1;
  bool storageGroups :1;
} _TFlushReq__isset;

class TFlushReq : public virtual ::apache::thrift::TBase {
 public:

  TFlushReq(const TFlushReq&);
  TFlushReq& operator=(const TFlushReq&);
  TFlushReq() : isSeq() {
  }

  virtual ~TFlushReq() noexcept;
  std::string isSeq;
  std::vector<std::string>  storageGroups;

  _TFlushReq__isset __isset;

  void __set_isSeq(const std::string& val);

  void __set_storageGroups(const std::vector<std::string> & val);

  bool operator == (const TFlushReq & rhs) const
  {
    if (__isset.isSeq != rhs.__isset.isSeq)
      return false;
    else if (__isset.isSeq && !(isSeq == rhs.isSeq))
      return false;
    if (__isset.storageGroups != rhs.__isset.storageGroups)
      return false;
    else if (__isset.storageGroups && !(storageGroups == rhs.storageGroups))
      return false;
    return true;
  }
  bool operator != (const TFlushReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFlushReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFlushReq &a, TFlushReq &b);

std::ostream& operator<<(std::ostream& out, const TFlushReq& obj);


class TSettleReq : public virtual ::apache::thrift::TBase {
 public:

  TSettleReq(const TSettleReq&);
  TSettleReq& operator=(const TSettleReq&);
  TSettleReq() {
  }

  virtual ~TSettleReq() noexcept;
  std::vector<std::string>  paths;

  void __set_paths(const std::vector<std::string> & val);

  bool operator == (const TSettleReq & rhs) const
  {
    if (!(paths == rhs.paths))
      return false;
    return true;
  }
  bool operator != (const TSettleReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSettleReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSettleReq &a, TSettleReq &b);

std::ostream& operator<<(std::ostream& out, const TSettleReq& obj);


class TSchemaNode : public virtual ::apache::thrift::TBase {
 public:

  TSchemaNode(const TSchemaNode&);
  TSchemaNode& operator=(const TSchemaNode&);
  TSchemaNode() : nodeName(), nodeType(0) {
  }

  virtual ~TSchemaNode() noexcept;
  std::string nodeName;
  int8_t nodeType;

  void __set_nodeName(const std::string& val);

  void __set_nodeType(const int8_t val);

  bool operator == (const TSchemaNode & rhs) const
  {
    if (!(nodeName == rhs.nodeName))
      return false;
    if (!(nodeType == rhs.nodeType))
      return false;
    return true;
  }
  bool operator != (const TSchemaNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSchemaNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSchemaNode &a, TSchemaNode &b);

std::ostream& operator<<(std::ostream& out, const TSchemaNode& obj);


class TSetTTLReq : public virtual ::apache::thrift::TBase {
 public:

  TSetTTLReq(const TSetTTLReq&);
  TSetTTLReq& operator=(const TSetTTLReq&);
  TSetTTLReq() : TTL(0) {
  }

  virtual ~TSetTTLReq() noexcept;
  std::vector<std::string>  storageGroupPathPattern;
  int64_t TTL;

  void __set_storageGroupPathPattern(const std::vector<std::string> & val);

  void __set_TTL(const int64_t val);

  bool operator == (const TSetTTLReq & rhs) const
  {
    if (!(storageGroupPathPattern == rhs.storageGroupPathPattern))
      return false;
    if (!(TTL == rhs.TTL))
      return false;
    return true;
  }
  bool operator != (const TSetTTLReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSetTTLReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSetTTLReq &a, TSetTTLReq &b);

std::ostream& operator<<(std::ostream& out, const TSetTTLReq& obj);


class TFile : public virtual ::apache::thrift::TBase {
 public:

  TFile(const TFile&);
  TFile& operator=(const TFile&);
  TFile() : fileName(), file() {
  }

  virtual ~TFile() noexcept;
  std::string fileName;
  std::string file;

  void __set_fileName(const std::string& val);

  void __set_file(const std::string& val);

  bool operator == (const TFile & rhs) const
  {
    if (!(fileName == rhs.fileName))
      return false;
    if (!(file == rhs.file))
      return false;
    return true;
  }
  bool operator != (const TFile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFile &a, TFile &b);

std::ostream& operator<<(std::ostream& out, const TFile& obj);


class TFilesResp : public virtual ::apache::thrift::TBase {
 public:

  TFilesResp(const TFilesResp&);
  TFilesResp& operator=(const TFilesResp&);
  TFilesResp() {
  }

  virtual ~TFilesResp() noexcept;
  TSStatus status;
  std::vector<TFile>  files;

  void __set_status(const TSStatus& val);

  void __set_files(const std::vector<TFile> & val);

  bool operator == (const TFilesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const TFilesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFilesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFilesResp &a, TFilesResp &b);

std::ostream& operator<<(std::ostream& out, const TFilesResp& obj);



#endif
